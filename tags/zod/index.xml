<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Zod on Aaron's Blog</title><link>https://and2352000.github.io/tags/zod/</link><description>Recent content in Zod on Aaron's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 18 Mar 2025 16:06:44 +0800</lastBuildDate><atom:link href="https://and2352000.github.io/tags/zod/index.xml" rel="self" type="application/rss+xml"/><item><title>用 Node.js 打造 Elegant API Framework：awilix、zod、zod-openapi 的導入與改變</title><link>https://and2352000.github.io/posts/10-elegant-framework-api-node-js/</link><pubDate>Tue, 18 Mar 2025 16:06:44 +0800</pubDate><guid>https://and2352000.github.io/posts/10-elegant-framework-api-node-js/</guid><description>&lt;h1 id="用-nodejs-打造-elegant-api-frameworkawilixzodzod-openapi-的導入與改變">用 Node.js 打造 Elegant API Framework：awilix、zod、zod-openapi 的導入與改變 &lt;a href="#%e7%94%a8-nodejs-%e6%89%93%e9%80%a0-elegant-api-frameworkawilixzodzod-openapi-%e7%9a%84%e5%b0%8e%e5%85%a5%e8%88%87%e6%94%b9%e8%ae%8a" class="anchor">🔗&lt;/a>&lt;/h1>&lt;p>今天我要來聊聊我的專案：&lt;a href="https://github.com/and2352000/elegant-api-framework-node-js" target="_blank" rel="noopener">Elegant API Framework for Node.js&lt;/a>。這個 API 框架目標是讓 Node.js API 專案開發變得更優雅，使用 &lt;code>awilix&lt;/code>、&lt;code>zod&lt;/code> 和 &lt;code>zod-openapi&lt;/code> 這三個工具，讓我的專案變得更乾淨、更易於維護。&lt;/p>
&lt;hr>
&lt;h2 id="專案初衷優雅與結構並存">專案初衷：優雅與結構並存 &lt;a href="#%e5%b0%88%e6%a1%88%e5%88%9d%e8%a1%b7%e5%84%aa%e9%9b%85%e8%88%87%e7%b5%90%e6%a7%8b%e4%b8%a6%e5%ad%98" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>我一開始做這個框架的時候，就想要解決 Node.js 開發中常見的痛點：依賴管理亂七八糟、資料驗證麻煩、API 文件難產。我用過 Express、Koa，也看過 NestJS 的做法，NestJS 基本上跟 Spring Boot 很像，NestJS 使用 TypeScript 的裝飾器來定義控制器、服務和其他組件，這與 Spring Boot 使用註解（Annotations）來配置應用程式的方式相似，但我很不喜歡被整個框架綁住，有時候覺得框架的存在限制的程式的擴展性，於是，我決定自己動手，打造一個既有彈性又有結構的框架。&lt;/p>
&lt;hr>
&lt;h2 id="導入-awilix依賴注入的救贖">導入 awilix：依賴注入的救贖 &lt;a href="#%e5%b0%8e%e5%85%a5-awilix%e4%be%9d%e8%b3%b4%e6%b3%a8%e5%85%a5%e7%9a%84%e6%95%91%e8%b4%96" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="為什麼選-awilix">為什麼選 awilix？ &lt;a href="#%e7%82%ba%e4%bb%80%e9%ba%bc%e9%81%b8-awilix" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>為了測試容易，我需要能夠輕鬆替換依賴，於是我開始找依賴注入（DI）的解決方案，我以前寫 Node.js 時，依賴管理全靠手動，以下是我之前為了達到 Dependency Injection 的寫法，這個寫法只能達到單例模式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 手動依賴注入
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UserService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">instance&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">UserService&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">readonly&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Database&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">getInstance&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">UserService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">UserService&lt;/span>.&lt;span style="color:#a6e22e">instance&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UserService&lt;/span>.&lt;span style="color:#a6e22e">instance&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">UserService&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Database&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">UserService&lt;/span>.&lt;span style="color:#a6e22e">instance&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>NestJS 的 DI 很強，但太重量級；InversifyJS 也不錯，但也要依靠實驗性的功能 &lt;code>reflect-metadata&lt;/code> 這點我不是很喜歡。最後我發現了 &lt;code>awilix&lt;/code>，一個輕量又直觀的 DI 容器，完美符合我的需求。&lt;/p></description></item></channel></rss>