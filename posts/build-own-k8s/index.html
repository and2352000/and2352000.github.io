<!doctype html><html lang=en-us><head><title>K8S DIY 架設手作 | Aaron's Blog</title>
<meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="環境準備 🔗 Public IP Domain Name 一台主機 灌好 Nginx 作為這台主機的入口 申請好 TLS 所需的憑證 一台 LoadBalancer 兼防火牆 Gitlab 帳號 Bootstrapping clusters with kubeadm 🔗官方安裝教學：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Full network connectivity between all machines in the cluster (public or private network is fine)."><meta name=generator content="Hugo 0.123.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/><span class=arrow>←</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>K8S DIY 架設手作</h1><div class=tip><time datetime="2022-08-23 14:01:30 +0800 +0800">Aug 23, 2022</time>
<span class=split>·
</span><span>626 words
</span><span class=split>·
</span><span>3 minute read</span></div><div class=content><h2 id=環境準備>環境準備 <a href=#%e7%92%b0%e5%a2%83%e6%ba%96%e5%82%99 class=anchor>🔗</a></h2><ul><li>Public IP</li><li>Domain Name</li><li>一台主機<ul><li>灌好 Nginx 作為這台主機的入口</li><li>申請好 TLS 所需的憑證</li></ul></li><li>一台 LoadBalancer 兼防火牆</li><li>Gitlab 帳號</li></ul><p><p class=markdown-image><img src=images/my_computer.png alt="My Computer"></p></p><h2 id=bootstrapping-clusters-with-kubeadm>Bootstrapping clusters with kubeadm <a href=#bootstrapping-clusters-with-kubeadm class=anchor>🔗</a></h2><p>官方安裝教學：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</p><ul><li>A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager.</li><li>2 GB or more of RAM per machine (any less will leave little room for your apps).</li><li>2 CPUs or more.</li><li>Full network connectivity between all machines in the cluster (public or private network is fine).</li><li>Unique hostname, MAC address, and product_uuid for every node. See here for more details.</li><li>Certain ports are open on your machines. See here for more details.</li><li>Swap disabled. You MUST disable swap in order for the kubelet to work properly.</li></ul><h2 id=installing-a-container-runtime>Installing a container runtime <a href=#installing-a-container-runtime class=anchor>🔗</a></h2><p>這裡可以選用你喜歡的，我選用 docker</p><h2 id=installing-kubeadm-kubelet-and-kubectl>Installing kubeadm, kubelet and kubectl <a href=#installing-kubeadm-kubelet-and-kubectl class=anchor>🔗</a></h2><ul><li>kubeadm: the command to bootstrap the cluster.</li><li>kubelet: the component that runs on all of the machines in your cluster and does things like starting pods and containers.</li><li>kubectl: the command line util to talk to your cluster.</li></ul><p>Update the apt package index and install packages needed to use the Kubernetes apt repository:</p><pre tabindex=0><code>sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl
</code></pre><p>Download the Google Cloud public signing key:</p><pre tabindex=0><code>sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
</code></pre><p>Add the Kubernetes apt repository:</p><pre tabindex=0><code>echo &#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list
</code></pre><p>Update apt package index, install kubelet, kubeadm and kubectl, and
pin their version:</p><pre tabindex=0><code>sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre><h2 id=kubeadm-init>kubeadm init <a href=#kubeadm-init class=anchor>🔗</a></h2><pre tabindex=0><code>kubeadm init
</code></pre><p>Get admin kubeconfig
To start using your cluster, you need to run the following as a regular user:</p><pre tabindex=0><code>  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre><p>當你去查看所以有的服務會發現，CoreDNS 一直是處在 pending
以下是官翻的 trouble shooting</p><h2 id=coredns-is-stuck-in-the-pending-state>CoreDNS is stuck in the Pending state <a href=#coredns-is-stuck-in-the-pending-state class=anchor>🔗</a></h2><p>This is expected and part of the design. kubeadm is network provider-agnostic, so the admin should install the pod network add-on of choice. You have to install a Pod Network before CoreDNS may be deployed fully. Hence the Pending state before the network is set up.</p><p>解決辦法：安裝網路套件
CoreDNS</p><ul><li><a href=https://cloud.tencent.com/developer/article/1820462 target=_blank rel=noopener>https://cloud.tencent.com/developer/article/1820462</a></li><li><a href=https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/ target=_blank rel=noopener>https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/</a></li><li>我選用 Weave</li></ul><pre tabindex=0><code>kubectl apply -f &#34;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#39;\n&#39;)&#34;
</code></pre><p>如果你只有一台伺服器要下下面這個指令才可以，讓 pod 部署在control-panel 同一台</p><pre tabindex=0><code>kubectl taint nodes --all node-role.kubernetes.io/control-plane- node-role.kubernetes.io/master-
</code></pre><h2 id=新增-user--role--rolebinding>新增 User & Role & RoleBinding <a href=#%e6%96%b0%e5%a2%9e-user--role--rolebinding class=anchor>🔗</a></h2><ul><li>簡單選用 RBAC 的策略</li><li>選擇User 認證方式，這邊選擇CA</li><li>Create Role</li><li>Create RoleBinding</li></ul><p>認證的三種方法: <a href=https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/ target=_blank rel=noopener>https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/</a><br>CA Ref: <a href=https://www.adaltas.com/en/2019/08/07/users-rbac-kubernetes/ target=_blank rel=noopener>https://www.adaltas.com/en/2019/08/07/users-rbac-kubernetes/</a><br>自製CA 產生Tool: <a href=https://gitlab.com/k8s71/k8s_config_gen target=_blank rel=noopener>https://gitlab.com/k8s71/k8s_config_gen</a><br>mTLS Ref: <a href=https://www.cloudflare.com/zh-tw/learning/access-management/what-is-mutual-tls/ target=_blank rel=noopener>https://www.cloudflare.com/zh-tw/learning/access-management/what-is-mutual-tls/</a></p><p>接下來就是部署服務</p><pre tabindex=0><code class="language-=yaml" data-lang="=yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: ee-api
  namespace: ee-dev
spec:
  selector:
    matchLabels:
      app: ee-api
  template:
    metadata:
      labels:
        app: ee-api
    spec:
      containers:
      - name: ee-api
        image: registry.gitlab.com/fcuee/ee-api:v0.0.15-release
        resources:
          limits:
            memory: &#34;300Mi&#34;
            cpu: &#34;500m&#34;   
        ports:
        - containerPort: 4000
        env:
        - name: FIREBASE_CRED
          valueFrom:
            secretKeyRef:
              name: ee-api-secret
              key: FIREBASE_CRED
              optional: false
...............省略.........
      imagePullSecrets:
      - name: docker-rg-key
</code></pre><p>記得給k8s docker registry 的權限</p><pre tabindex=0><code>kubectl create secret docker-registry regcred -n=ee-dev --docker-server=registry.gitlab.com --docker-username=&lt;username&gt; --docker-password=&lt;token&gt; --docker-email=&lt;email&gt; -n=ee-dev
</code></pre><p>Config: <a href=https://gitlab.com/k8s71/config_env target=_blank rel=noopener>https://gitlab.com/k8s71/config_env</a></p><p>Apply deployment yaml， pod 啟動了，透過port forword 看到服務的內容
接下來就是要把服務開到 public</p><h2 id=ingress>Ingress <a href=#ingress class=anchor>🔗</a></h2><p>官網介紹 Ingress 的用途：https://kubernetes.io/docs/concepts/services-networking/ingress/</p><p>Ingress 有很多種，這裡選用nginx ingress(魔改過的ngnix)</p><ul><li>Nginx ingress yaml
<a href=https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml target=_blank rel=noopener>https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml</a>
官方Nginx Ingress Doc：https://docs.nginx.com/nginx-ingress-controller/</li></ul><p>接下來去查看Service</p><pre tabindex=0><code>kubectl get service -A
</code></pre><p>你會發現 ngnix controller externel IP 是 pending
然後開始等待&mldr;等待&mldr;等待良人回來那裡啊！！！ 回憶&mldr;.
ＱＱ 自己架設的 k8s 不像 GKE 一樣有 LoadBalancer 幫你分配 IP</p><p>那有沒有比較簡單的做法，有的 NodePort 直接把 Port 對外
於是我就可以在這台電腦上</p><pre tabindex=0><code>curl localhost:30088
</code></pre><p>然後你會拿到 404 page not found
就算是成功了</p><p>接下來我們就要把服務與Ingress 串起來，以下設定</p><ul><li>給開service 一個 ExternalName，並與 nginx-ingress 同 namespace</li></ul><pre tabindex=0><code class="language-=yaml" data-lang="=yaml">  apiVersion: v1
  kind: Service
  metadata:
    name: ee-api-service
    namespace: ingress-nginx
  spec:
    type: ExternalName
    externalName: ee-api-service.ee-dev.svc.cluster.local
    selector:
      app: ee-api
    ports:
    - port: 4000
      targetPort: 4000
</code></pre><ul><li>設定 Ingress 的路由</li></ul><pre tabindex=0><code class="language-=yaml" data-lang="=yaml">  apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    name: ingress-ee-api
    namespace: ingress-nginx
    annotations:
     kubernetes.io/ingress.class: nginx
  spec:
    rules:
    - host: &#34;domain.example.com&#34;
      http:
        paths:
        - pathType: Prefix
          path: &#34;/&#34;
          backend:
            service:
              name: ee-api-service
              port:
                number: 4000
</code></pre><p>然後就結束了嗎！！！</p><pre tabindex=0><code>curl domain.example.com
</code></pre><p>又再度看到 404</p><p>等等 domain.example.com 是哪裡來的，我們前面打的不是 Domain Name 而是 localhost 啊</p><p>所以我運用我原來service上就有的nginx 作為 LoadBalancer 透過 virtual host reverse proxy 轉發到 localhost:30088 上</p><p>然後終於通了，可喜可賀</p></div><div class=tags><a href=https://and2352000.github.io/tags/k8s>k8s</a>
<a href=https://and2352000.github.io/tags/docker>docker</a></div></section></main><footer id=footer><div class=copyright>© Copyright
2024
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span></div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>