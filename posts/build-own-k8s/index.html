<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>K8S DIY 架設手作 | Aaron's Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="環境準備 Public IP Domain Name 一台主機 灌好 Nginx 作為這台主機的入口 申請好 TLS 所需的憑證 一台 LoadBalancer 兼防火牆 Gitlab 帳號 Bootstrapping clusters with kubeadm 官方安裝教學：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Full network connectivity between all machines in the cluster (public or private network is fine)."><meta name=generator content="Hugo 0.102.3"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="K8S DIY 架設手作"><meta property="og:description" content="環境準備 Public IP Domain Name 一台主機 灌好 Nginx 作為這台主機的入口 申請好 TLS 所需的憑證 一台 LoadBalancer 兼防火牆 Gitlab 帳號 Bootstrapping clusters with kubeadm 官方安裝教學：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Full network connectivity between all machines in the cluster (public or private network is fine)."><meta property="og:type" content="article"><meta property="og:url" content="https://and2352000.github.io/posts/build-own-k8s/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-23T14:01:30+08:00"><meta property="article:modified_time" content="2022-08-23T14:01:30+08:00"><meta itemprop=name content="K8S DIY 架設手作"><meta itemprop=description content="環境準備 Public IP Domain Name 一台主機 灌好 Nginx 作為這台主機的入口 申請好 TLS 所需的憑證 一台 LoadBalancer 兼防火牆 Gitlab 帳號 Bootstrapping clusters with kubeadm 官方安裝教學：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Full network connectivity between all machines in the cluster (public or private network is fine)."><meta itemprop=datePublished content="2022-08-23T14:01:30+08:00"><meta itemprop=dateModified content="2022-08-23T14:01:30+08:00"><meta itemprop=wordCount content="623"><meta itemprop=keywords content="k8s,docker,"><meta name=twitter:card content="summary"><meta name=twitter:title content="K8S DIY 架設手作"><meta name=twitter:description content="環境準備 Public IP Domain Name 一台主機 灌好 Nginx 作為這台主機的入口 申請好 TLS 所需的憑證 一台 LoadBalancer 兼防火牆 Gitlab 帳號 Bootstrapping clusters with kubeadm 官方安裝教學：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Full network connectivity between all machines in the cluster (public or private network is fine)."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Aaron's Blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">K8S DIY 架設手作</h1><time class="f6 mv4 dib tracked" datetime=2022-08-23T14:01:30+08:00>August 23, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id=環境準備>環境準備</h2><ul><li>Public IP</li><li>Domain Name</li><li>一台主機<ul><li>灌好 Nginx 作為這台主機的入口</li><li>申請好 TLS 所需的憑證</li></ul></li><li>一台 LoadBalancer 兼防火牆</li><li>Gitlab 帳號</li></ul><p><img src=images/my_computer.png alt="My Computer"></p><h2 id=bootstrapping-clusters-with-kubeadm>Bootstrapping clusters with kubeadm</h2><p>官方安裝教學：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</p><ul><li>A compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager.</li><li>2 GB or more of RAM per machine (any less will leave little room for your apps).</li><li>2 CPUs or more.</li><li>Full network connectivity between all machines in the cluster (public or private network is fine).</li><li>Unique hostname, MAC address, and product_uuid for every node. See here for more details.</li><li>Certain ports are open on your machines. See here for more details.</li><li>Swap disabled. You MUST disable swap in order for the kubelet to work properly.</li></ul><h2 id=installing-a-container-runtime>Installing a container runtime</h2><p>這裡可以選用你喜歡的，我選用 docker</p><h2 id=installing-kubeadm-kubelet-and-kubectl>Installing kubeadm, kubelet and kubectl</h2><ul><li>kubeadm: the command to bootstrap the cluster.</li><li>kubelet: the component that runs on all of the machines in your cluster and does things like starting pods and containers.</li><li>kubectl: the command line util to talk to your cluster.</li></ul><p>Update the apt package index and install packages needed to use the Kubernetes apt repository:</p><pre tabindex=0><code>sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl
</code></pre><p>Download the Google Cloud public signing key:</p><pre tabindex=0><code>sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
</code></pre><p>Add the Kubernetes apt repository:</p><pre tabindex=0><code>echo &#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list
</code></pre><p>Update apt package index, install kubelet, kubeadm and kubectl, and
pin their version:</p><pre tabindex=0><code>sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre><h2 id=kubeadm-init>kubeadm init</h2><pre tabindex=0><code>kubeadm init
</code></pre><p>Get admin kubeconfig
To start using your cluster, you need to run the following as a regular user:</p><pre tabindex=0><code>  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre><p>當你去查看所以有的服務會發現，CoreDNS 一直是處在 pending
以下是官翻的 trouble shooting</p><h2 id=coredns-is-stuck-in-the-pending-state>CoreDNS is stuck in the Pending state</h2><p>This is expected and part of the design. kubeadm is network provider-agnostic, so the admin should install the pod network add-on of choice. You have to install a Pod Network before CoreDNS may be deployed fully. Hence the Pending state before the network is set up.</p><p>解決辦法：安裝網路套件
CoreDNS</p><ul><li><a href=https://cloud.tencent.com/developer/article/1820462>https://cloud.tencent.com/developer/article/1820462</a></li><li><a href=https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/</a></li><li>我選用 Weave</li></ul><pre tabindex=0><code>kubectl apply -f &#34;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#39;\n&#39;)&#34;
</code></pre><p>如果你只有一台伺服器要下下面這個指令才可以，讓 pod 部署在control-panel 同一台</p><pre tabindex=0><code>kubectl taint nodes --all node-role.kubernetes.io/control-plane- node-role.kubernetes.io/master-
</code></pre><h2 id=新增-user--role--rolebinding>新增 User & Role & RoleBinding</h2><ul><li>簡單選用 RBAC 的策略</li><li>選擇User 認證方式，這邊選擇CA</li><li>Create Role</li><li>Create RoleBinding</li></ul><p>認證的三種方法: <a href=https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/>https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/</a><br>CA Ref: <a href=https://www.adaltas.com/en/2019/08/07/users-rbac-kubernetes/>https://www.adaltas.com/en/2019/08/07/users-rbac-kubernetes/</a><br>自製CA 產生Tool: <a href=https://gitlab.com/k8s71/k8s_config_gen>https://gitlab.com/k8s71/k8s_config_gen</a><br>mTLS Ref: <a href=https://www.cloudflare.com/zh-tw/learning/access-management/what-is-mutual-tls/>https://www.cloudflare.com/zh-tw/learning/access-management/what-is-mutual-tls/</a></p><p>接下來就是部署服務</p><pre tabindex=0><code class="language-=yaml" data-lang="=yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: ee-api
  namespace: ee-dev
spec:
  selector:
    matchLabels:
      app: ee-api
  template:
    metadata:
      labels:
        app: ee-api
    spec:
      containers:
      - name: ee-api
        image: registry.gitlab.com/fcuee/ee-api:v0.0.15-release
        resources:
          limits:
            memory: &#34;300Mi&#34;
            cpu: &#34;500m&#34;   
        ports:
        - containerPort: 4000
        env:
        - name: FIREBASE_CRED
          valueFrom:
            secretKeyRef:
              name: ee-api-secret
              key: FIREBASE_CRED
              optional: false
...............省略.........
      imagePullSecrets:
      - name: docker-rg-key
</code></pre><p>記得給k8s docker registry 的權限</p><pre tabindex=0><code>kubectl create secret docker-registry regcred -n=ee-dev --docker-server=registry.gitlab.com --docker-username=&lt;username&gt; --docker-password=&lt;token&gt; --docker-email=&lt;email&gt; -n=ee-dev
</code></pre><p>Config: <a href=https://gitlab.com/k8s71/config_env>https://gitlab.com/k8s71/config_env</a></p><p>Apply deployment yaml， pod 啟動了，透過port forword 看到服務的內容
接下來就是要把服務開到 public</p><h2 id=ingress>Ingress</h2><p>官網介紹 Ingress 的用途：https://kubernetes.io/docs/concepts/services-networking/ingress/</p><p>Ingress 有很多種，這裡選用nginx ingress(魔改過的ngnix)</p><ul><li>Nginx ingress yaml
<a href=https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml>https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml</a>
官方Nginx Ingress Doc：https://docs.nginx.com/nginx-ingress-controller/</li></ul><p>接下來去查看Service</p><pre tabindex=0><code>kubectl get service -A
</code></pre><p>你會發現 ngnix controller externel IP 是 pending
然後開始等待&mldr;等待&mldr;等待良人回來那裡啊！！！ 回憶&mldr;.
ＱＱ 自己架設的 k8s 不像 GKE 一樣有 LoadBalancer 幫你分配 IP</p><p>那有沒有比較簡單的做法，有的 NodePort 直接把 Port 對外
於是我就可以在這台電腦上</p><pre tabindex=0><code>curl localhost:30088
</code></pre><p>然後你會拿到 404 page not found
就算是成功了</p><p>接下來我們就要把服務與Ingress 串起來，以下設定</p><ul><li>給開service 一個 ExternalName，並與 nginx-ingress 同 namespace</li></ul><pre tabindex=0><code class="language-=yaml" data-lang="=yaml">  apiVersion: v1
  kind: Service
  metadata:
    name: ee-api-service
    namespace: ingress-nginx
  spec:
    type: ExternalName
    externalName: ee-api-service.ee-dev.svc.cluster.local
    selector:
      app: ee-api
    ports:
    - port: 4000
      targetPort: 4000
</code></pre><ul><li>設定 Ingress 的路由</li></ul><pre tabindex=0><code class="language-=yaml" data-lang="=yaml">  apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    name: ingress-ee-api
    namespace: ingress-nginx
    annotations:
     kubernetes.io/ingress.class: nginx
  spec:
    rules:
    - host: &#34;domain.example.com&#34;
      http:
        paths:
        - pathType: Prefix
          path: &#34;/&#34;
          backend:
            service:
              name: ee-api-service
              port:
                number: 4000
</code></pre><p>然後就結束了嗎！！！</p><pre tabindex=0><code>curl domain.example.com
</code></pre><p>又再度看到 404</p><p>等等 domain.example.com 是哪裡來的，我們前面打的不是 Domain Name 而是 localhost 啊</p><p>所以我運用我原來service上就有的nginx 作為 LoadBalancer 透過 virtual host reverse proxy 轉發到 localhost:30088 上</p><p>然後終於通了，可喜可賀</p><ul class=pa0><li class="list di"><a href=/tags/k8s class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">k8s</a></li><li class="list di"><a href=/tags/docker class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">docker</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://and2352000.github.io>&copy; Aaron's Blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>